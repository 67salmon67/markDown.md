# CH1 課程筆記

# 1 課程筆記

## 課程重點
1. 條件式與數學式不同，是一種運算，會判斷出1或0的結果。
2. if 後面若沒大括號，只會執行下方一行程式碼。
## 程式練習
### a113: APCS 110.09 1.七言對聯
#### 題目概述
中文依照發音方式可以分為平聲與仄聲，假設我們把平聲標記為 0 而仄聲標記為 1

一個七言對聯包含兩個句子，每個句子包含恰好七個字


七言對聯有三個限制：
A: 二四不同二六同：每一句第二、四個字必須不同平仄，而第二、六個字必須相同平仄
B: 仄起平收：第一句的結尾必須為仄聲，第二句的結尾必須為平聲
C: 上下相對：第一、二句的第二、四、六個字平仄必須不同


給你 n 組對聯，分別用0, 1 代表平仄，請輸出它違反了哪幾條規則
若以上規則皆無違反，請輸出None

#### 解題思路
1. 用循環輸入兩個空矩陣
2. 用||判斷A B C
3. 輸出答案

#### 程式碼
```cpp=
#include<bits/stdc++.h>
using namespace std;
int main(){
int n;
cin>>n;
int a[7], b[7];
for(int j=0; j<n; j++){
for (int i=0;i<7;i++){
cin>>a[i];
}//輸入矩陣
for (int i=0;i<7;i++){
cin>>b[i];
}//輸入矩陣
string ans = "";
if(a[1]== a[3] ||a[1] != a[5]||b[1]== b[3] ||b[1] != b[5]){
ans+="A";
}//判斷A
if(a[6]==0||b[6] == 1){
ans+="B";
}//判斷B
if (a[1]==b[1]||a[3] == b[3]||a[5] == b[5]){
ans+="C";
}//判斷C
if (ans==""){
cout<<"None"<<endl;//沒有答案
}else{
cout<<ans<<endl;//輸出答案
}
}
return 0;
}

```
![image](https://hackmd.io/_uploads/H1qHx2L5le.png)
## 章節統整/心得
解題遇到的問題
1.一開始忘記如何輸入多個矩陣
2.忘記用}與;

此題主要內容為邏輯判斷，用於程式的流程處理，基本上語法算簡單，但在應用部分則須思考清楚條件式該如何設定，不然可能會有部分情況無法處理



# 2 課程筆記

## 課程重點
1.陣列的基本操作與走訪
2.條件判斷（邊界情況特別處理）
3.利用題目限制（不會有相鄰壞圍籬）簡化判斷


## 程式練習
### a134: APCS 110.11 1.修補圍籬
#### 題目概述
有一個農場有寬度為 n 的圍籬, 每個圍籬都有各自的高度 h[1],h[2],⋯,h[n]
有些圍籬被吹斷了，農場主人要來修補這些圍籬，但他忘記這些壞掉的圍籬原本高度是多少，為了減少成本，他會取斷掉的圍籬位置相鄰左邊和右邊較小的那個高度填上去，問需要多少成本

題目保證不會有兩個相鄰的吹斷圍籬，而穿斷的圍籬有可能位在邊界
#### 解題思路
1. 讀入圍籬數量與每個圍籬高度（0 代表壞掉）。
2.逐一檢查高度為 0 的位置。
3.若在左邊界，只能用右邊高度修補。
4.若在右邊界，只能用左邊高度修補。
5.若在中間，取左右相鄰圍籬中較小的高度。
6.將修補高度加總即為總成本。

#### 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() 
{
  int n;
    cin>>n;
 int a[n];    // 讀入圍籬高度
for (int i=0;i<n;i++){
cin>>a[i];
}
int ans=0;    // 計算修補成本
for (int i=0;i<n;i++){
  if(a[i]==0){// 壞掉的圍籬
    if(i==0){
      ans+=a[i+1];// 左邊界
    }else if(i==n-1){
      ans+=a[i-1];// 右邊界
    }else{
      ans+=min(a[i-1],a[i+1]);// 取較小值
    }
}
}
cout<<ans;
return 0;
}
```
![image](https://hackmd.io/_uploads/r1lTsYihge.png)


## 章節統整/心得
這題重點在於邊界判斷與善用題目條件，只要確保不會存取到不存在的陣列位置，邏輯就能順利完成，是練習陣列與 if 判斷的好題目。


# 3 課程筆記

## 課程重點
1.數字大小比較
2.條件判斷（相等與不相等的情況）
3.依題意控制輸出格式
## 程式練習
### a153: APCS 111.06 1.數字遊戲
#### 題目概述
給三個介於 1～9 的整數 A1、A2、A3。
先輸出眾數的出現次數 P，再將數字去除重複後由大到小輸出。
#### 解題思路
1.先算眾數
2.算出max min
3.比大小
#### 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() 
{
  int a,b,c,P,mid;
  cin>>a>>b>>c;
  int max = a;
  if (b > max){
      max = b;}
  if (c > max){
      max = c;}
  int min = a;
  if (b < min){
    min= b;}
  if (c < min){
    min = c;}
  if(a==b&&b==c){    // 三個數相同
    P=3;
    cout<<P<<" "<<a;
  }    
  else if(a==b||b==c||a==c){    // 兩個數相同
    P=2;
    cout<<P<<" "<<max<<" "<<min;    // 三個數都不同
  }
  else{
    P=1;
    cout<<P<<" ";
    if(a!=max&&a!=min){
      mid=a;
    }
    else if(b!=max&&b!=min){
      mid=b;
    }
    else if(c!=max&&c!=min){
      mid=c;
    }
    cout<<max<<" "<<mid<<" "<<min;
  }
 
  return 0;
}

```
![image](https://hackmd.io/_uploads/B1ROH1eolx.png)
## 章節統整/心得
這題我用暴力法硬開，下次要多想想。
## 解題遇到的問題
1.前幾次忘記加" "，導致WA，最後才發現，下次要記得加空格。



# 4 課程筆記

## 課程重點
1.相鄰資料的比較
2.最大值與最小值的更新

## 程式練習
### a154: APCS 111.10 1.巴士站牌
#### 題目概述
平面上有 n 個巴士站，第 i 個巴士站的位置可以用座標點 (xi, yi) 來表示。
兩個巴士站之間行進的時間是這兩個巴士站座標的曼哈頓距離。曼哈頓距離的定義如下：對於兩個座標點 (x1, y1) 與 (x2, y2)，兩點之間曼哈頓距離為 |x1 - x2| + |y1 - y2|。你今天要從巴士站 1 坐車到巴士站 n，中間依序經過巴士站 2, 3, 4, ⋯, (n-1)。
請計算過程中相鄰兩站的行進時間的最大值與最小值。
#### 解題思路
1. 先讀入第一個巴士站座標作為起點。
2.依序讀入下一站座標，計算與前一站的曼哈頓距離。
3.每算出一段距離就更新最大值與最小值。
4.將目前站點更新為下一站，繼續計算。
5.最後輸出最大與最小的行進時間。

#### 程式碼
```cpp=
#include <iostream>
using namespace std;

#include <iostream>
using namespace std;

int main() 
{
  int n;
  cin>>n;                    // 巴士站數量
  int nowx,nowy,x,y,d;
  int maxd=0,mind=999;       // 記錄最大與最小距離
  cin>>nowx>>nowy;           // 讀入第一個站牌座標
  for(int i=0;i<n-1;i++){
    cin>>x>>y;               // 讀入下一站座標
  d=abs(nowx-x)+abs(nowy-y); // 計算曼哈頓距離
  if(d>maxd){
    maxd=d;                  // 更新最大距離
  }
  if(d<mind){
    mind=d;                  // 更新最小距離
  }
  nowx=x;
  nowy=y;                    // 更新目前站牌
  }
  cout<<maxd<<" "<<mind;     // 輸出結果
  return 0;
}
```
![image](https://hackmd.io/_uploads/rJqfZxgjgl.png)


## 章節統整/心得
透過逐站計算距離並即時更新最大值與最小值，讓我更熟悉在迴圈中進行比較與紀錄結果的寫法。
同時也提醒自己要特別注意初始值設定與邊界條件，才能避免計算錯誤。
## 解題遇到的問題
1.最小值需要先給一個夠大的初始值，否則無法正確更新。



# 5 課程筆記

## 課程重點
1. 方向的編碼與狀態紀錄（用數字代表方向）
2.相鄰兩點座標判斷移動方向
3.利用「目前方向 → 下一方向」判斷左轉、右轉、迴轉
4.模組運算（% 4）在方向循環上的應用
## 程式練習
### a156: APCS 112.06 1.路徑偵測
#### 題目概述
給一個二維平面，座標如同數學的二維座標(Ｙ正為北，Ｘ正為東)。起始位置在 (0, 0)，接下來會有n個座標，你需要按照這些座標點的順序移動，保證僅會垂直或水平方向上移動，不會斜向移動，且第一個點保證一定是Ｘ軸正的位置(初始方向向右)。
請輸出這條路徑中，左轉、右轉、迴轉的個數分別為多少。
#### 解題思路
1.將方向編碼為四個整數
 0：向右（東）
 1：向上（北）
 2：向左（西）
 3：向下（南）
2.起始方向固定為向右（nowdir = 0）。
3.每讀入一個新座標，與前一座標比較，判斷目前移動方向 dir。
4.將新方向與舊方向比較：
(nowdir + 1) % 4 → 左轉
(nowdir + 2) % 4 → 迴轉
(nowdir + 3) % 4 → 右轉
5.統計三種轉向次數，並更新目前位置與方向。
6.最後輸出左轉、右轉、迴轉的次數。


#### 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() 
{
  int n,l=0,r=0,d=0,x,y,dir,nowdir=0,nowx,nowy;
    // n點數；l左轉 r右轉 d迴轉；nowdir目前方向
  cin>>n>>nowx>>nowy; 
    // 讀入點數與起始座標（方向預設向右）
  for (int i=0;i<n-1;i++){
    cin>>x>>y; // 讀入下一個座標
    if(nowx>x) dir=2;        // 向左
    else if(nowx<x) dir=0;   // 向右
    else if(nowy>y) dir=3;   // 向下
    else dir=1;              // 向上
    if(dir==(nowdir+1)%4){l++;} // 左轉
    if(dir==(nowdir+2)%4){d++;} // 迴轉
    if(dir==(nowdir+3)%4){r++;} // 右轉
    nowx=x; nowy=y; nowdir=dir; // 更新目前座標與方向
  }
  cout<<l<<" "<<r<<" "<<d; // 輸出左轉 右轉 迴轉
  return 0;
}
```
![image](https://hackmd.io/_uploads/ryoU-Qtixl.png)


## 章節統整/心得
這題讓我第一次真正體會到「方向狀態」的概念，用數字表示方向後，轉向判斷就能用簡單的數學運算完成，比用一堆 if 判斷來得清楚且不容易出錯。



# 6 課程筆記

## 課程重點
1. 分類統計（左邊 / 右邊）
2.同時紀錄「數量」與「極值」
3.條件判斷下的最終決策
## 程式練習
### a157: APCS 112.10 1.機械鼠
#### 題目概述
有n個位置上有食物，另外有一隻老鼠一開始位於位置x。老鼠在開始覓食前要選擇今天要往左邊或往右移動去尋找食物，經過食物時可以停下來吃食物，吃完後可以選擇繼續往相同方向移動，或者是結束今天的覓食。
請問老鼠最多能吃到多少個食物，以及最後停下來吃食物的位置。
#### 解題思路
1.讀入老鼠起始位置 x 與食物數量 n。
2.逐一讀入每個食物的位置：
若在 x 右邊（含 x），計入右邊數量 c，並更新最右位置 max
若在 x 左邊（含 x），計入左邊數量 b，並更新最左位置 min
3.比較左右兩邊可吃的食物數量：
右邊多 → 輸出右邊數量與最遠位置
左邊多 → 輸出左邊數量與最遠位置

#### 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() 
{ int x,n,c=0,b=0,a[20],max,min; 
 // x起點 n食物數 c右邊數 b左邊數
cin>>x>>n; // 讀入起始位置與食物數
max=x; min=x; // 初始化左右最遠位置
for(int i=0;i<n;i++){ 
  cin>>a[i]; // 讀入食物位置
  if(a[i]>=x){ // 在右邊（含起點）
    c++; 
    if (a[i]>max) max=a[i]; // 更新最遠右邊
  }
  if(a[i]<=x){ // 在左邊（含起點）
    b++;
    if (a[i]<min) min=a[i]; // 更新最遠左邊
  }
} 
if(c>b) cout<<c<<" "<<max; // 右邊較多
else if(b>c) cout<<b<<" "<<min; // 左邊較多
return 0; 
}
```
![image](https://hackmd.io/_uploads/ByAZ9mtixe.png)



## 章節統整/心得
這題讓我練習在一次迴圈中，同時處理「數量統計」與「最大最小值更新」，也讓我更熟悉如何根據題意拆成左右兩種情況來處理。

解題遇到的問題
1.一開始用的不是a[20]，導致出現一些錯誤。



# 7 課程筆記

## 課程重點
1. 多筆資料中找最大值與次大值
2.同步保存「能力值」與「原始屬性」
3.條件更新順序的重要性
## 程式練習
### a158: APCS 113.01 1.遊戲選角
#### 題目概述
有n個角色，每個角色有攻擊力和防禦力。
角色的能力值是攻擊力和防禦力的平方和，輸出能力值第二大的攻擊力和防禦力數值。
#### 解題思路
1.使用兩組變數：
第一大能力值（f）與其攻防（fa, fd）
第二大能力值（s）與其攻防（sa, sd）
2.每讀入一個角色：
若能力值大於第一大，原本第一大降為第二大
否則若大於第二大，更新第二大
3.最後輸出第二大能力值對應的攻擊力與防禦力。


#### 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() 
{ int f=0,s=0,fa=0,fd=0,sa=0,sd=0,ab,a,d; 
 // f最大 s第二大；fa fd 對應最大；sa sd 對應第二大
int n;
cin >> n; // 角色數量
for (int i = 0; i < n; i++) {
  cin>>a>>d; // 讀入攻擊與防禦
  ab=a*a+d*d; // 計算能力值
  if(ab>f){ // 新的最大值
    s=f; sa=fa; sd=fd; // 原最大降為第二大
    f=ab; fa=a; fd=d; // 更新最大
  }
  else if(ab>s){ // 介於最大與第二大
    s=ab; sa=a; sd=d;
  }
}
cout<<sa<<" "<<sd; // 輸出第二大能力值的攻防
return 0; 
}
```
![image](https://hackmd.io/_uploads/rkkSR7Fjex.png)




## 章節統整/心得
這題是典型的「最大、次大值」問題，但困難點在於不只要記數值，還要同步記錄對應的攻防資料，讓我更注意更新順序的重要性。



